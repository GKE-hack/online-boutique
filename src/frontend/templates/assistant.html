<!--
 Copyright 2020 Google LLC

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->

{{ define "assistant" }}

{{ template "header" . }}
<div {{ with $.platform_css }} class="{{.}}" {{ end }}>
  <span class="platform-flag">
    {{$.platform_name}}
  </span>
</div>

<main role="main">
  <div class="container">
    <div class="row">
      <div class="col-md-12">
        <div id="chat-modal" class="chat-modal">
          <div id="bot-messages" class="bot-messages">
            <p class="bot-message">
              <span class="bot-message-text">Hi! I'm your Online Boutique shopping assistant powered by Gemini 2.0 Flash. I can help you find products, answer questions about our catalog, and make personalized recommendations.</span>
            </p>
            <p class="bot-message">
              <span class="bot-message-text">What are you looking for today? You can ask me about specific products, categories, or just tell me what you need!</span>
            </p>
          </div>
          <div class="bot-input">
            <input id="bot-input-text" type="text" class="bot-input-text" placeholder="Ask me about products, categories, or what you're looking for...">
            <button id="bot-input-button" class="bot-input-button">Send</button>
          </div>
        </div>
      </div>
    </div>
  </div>
</main>

<script>
  // Store conversation history for context
  var conversationHistory = [];
  var sessionId = null;

  // Load session from localStorage
  function loadSession() {
    try {
      const savedSession = localStorage.getItem('chatSessionId');
      const savedHistory = localStorage.getItem('chatHistory');

      if (savedSession) {
        sessionId = savedSession;
      } else {
        sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        localStorage.setItem('chatSessionId', sessionId);
      }

      if (savedHistory) {
        conversationHistory = JSON.parse(savedHistory);
      }
    } catch (e) {
      console.error('Failed to load session:', e);
    }
  }

  // Save session to localStorage
  function saveSession() {
    try {
      localStorage.setItem('chatHistory', JSON.stringify(conversationHistory));
    } catch (e) {
      console.error('Failed to save session:', e);
    }
  }

  // Parse markdown to HTML
  function parseMarkdown(text) {
    let html = text
      .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
      .replace(/\*(.*?)\*/g, '<em>$1</em>')
      .replace(/```(.*?)```/gs, '<pre><code>$1</code></pre>')
      .replace(/`(.*?)`/g, '<code>$1</code>')
      .replace(/^\* (.+)$/gm, '<li>$1</li>')
      .replace(/^- (.+)$/gm, '<li>$1</li>')
      .replace(/^\d+\. (.+)$/gm, '<li>$1</li>')
      .replace(/\n/g, '<br>');

    html = html.replace(/(<li>.*?<\/li>(<br>)?)+/g, function(match) {
      return '<ul>' + match.replace(/<br>/g, '') + '</ul>';
    });

    return html;
  }

  function extractIdsFromString(message) {
    const idPattern = /\[([a-zA-Z0-9-]+)\]/g;
    const matches = message.matchAll(idPattern);
    const ids = [];
    for (const match of matches) {
      ids.push(match[1]);
    }

    return ids;
  }

  const chatModal = document.getElementById("chat-modal");
  const botMessages = document.getElementById("bot-messages");
  const botbutton = document.getElementById("bot-input-button");
  const botinput = document.getElementById("bot-input-text");

  async function main() {
    // Load session on page load
    loadSession();

    botbutton.addEventListener("click", handleButtonClick);

    botinput.addEventListener("keypress", (event) => {
      if (event.key === "Enter") {
        botbutton.click();
      }
    });
  }

  async function handleButtonClick() {
    if(!botinput.value || !botinput.value.trim()){
      return;
    }

    // Construct and render user message
    console.log("bot button clicked");
    const message = botinput.value;
    console.log("message: " + message);

    // Add to conversation history
    conversationHistory.push("User: " + message);

    const usermessage = document.createElement("p");
    const userMessageSpan = document.createElement("span");
    userMessageSpan.innerText = message;
    userMessageSpan.classList.add("user-message-text");
    usermessage.classList.add("user-message");
    usermessage.appendChild(userMessageSpan);
    botMessages.appendChild(usermessage);
    botMessages.scrollTo(0, botMessages.scrollHeight);
    botinput.value = "";

    // Disable send button and input field
    botbutton.disabled = true;
    botinput.disabled = true;
    console.log("bot is typing");

    // Try streaming first
    const useStreaming = true;
    let responseJson = null;
    let botMessage = null;
    let botMessageSpan = null;
    let extractedIds = [];

    if (useStreaming) {
      // Create bot message for streaming
      botMessage = document.createElement("p");
      botMessageSpan = document.createElement("span");
      botMessageSpan.innerHTML = "";
      botMessageSpan.classList.add("bot-message-text");
      botMessage.classList.add("bot-message");
      botMessage.appendChild(botMessageSpan);
      botMessages.appendChild(botMessage);
      botMessages.scrollTo(0, botMessages.scrollHeight);

      let fullResponse = '';
      let metadata = null;

      try {
        const response = await fetch("{{ $.baseUrl }}/chat/stream", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            message: message,
            history: conversationHistory.slice(-10),
            session_id: sessionId
          }),
        });

        if (!response.ok) {
          throw new Error('Streaming not available');
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');
          buffer = lines.pop() || '';

          for (const line of lines) {
            if (line.startsWith('data: ')) {
              const data = line.slice(6);
              if (data) {
                try {
                  const parsed = JSON.parse(data);
                  if (parsed.text) {
                    fullResponse += parsed.text;
                    botMessageSpan.innerHTML = parseMarkdown(fullResponse.replace(/\n+[-*\d][\S\s]*/g, ""));
                    botMessages.scrollTo(0, botMessages.scrollHeight);
                  } else if (parsed.metadata) {
                    metadata = parsed.metadata;
                    if (metadata.session_id) {
                      sessionId = metadata.session_id;
                      localStorage.setItem('chatSessionId', sessionId);
                    }
                    if (metadata.recommended_products) {
                      extractedIds = metadata.recommended_products;
                    }
                  } else if (parsed.done) {
                    break;
                  }
                } catch (e) {
                  console.error('Error parsing SSE:', e);
                }
              }
            }
          }
        }

        conversationHistory.push("Assistant: " + fullResponse);
        saveSession();
        responseJson = { message: fullResponse };

      } catch (error) {
        console.error('Streaming failed, falling back:', error);
        // Remove streaming message
        botMessages.removeChild(botMessage);
        // Fall back to regular endpoint
        useStreaming = false;
      }
    }

    if (!useStreaming) {
      // Fallback to regular non-streaming
      botMessage = document.createElement("p");
      botMessage.classList.add("bot-message-loading");
      botMessageSpan = document.createElement("span");
      botMessageSpan.innerText = "";
      botMessageSpan.classList.add("bot-message-text");
      botMessage.classList.add("bot-message");
      botMessage.appendChild(botMessageSpan);
      botMessages.appendChild(botMessage);
      botMessages.scrollTo(0, botMessages.scrollHeight);

      const response = await fetch("{{ $.baseUrl }}/bot", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          message: message,
          history: conversationHistory.slice(-10),
          session_id: sessionId
        }),
      });
      responseJson = await response.json();
      console.log(responseJson);

      if (responseJson.session_id) {
        sessionId = responseJson.session_id;
        localStorage.setItem('chatSessionId', sessionId);
      }

      extractedIds = extractIdsFromString(responseJson.message);
      console.log(extractedIds);

      conversationHistory.push("Assistant: " + responseJson.message);
      saveSession();

      botMessageSpan.innerHTML = parseMarkdown(responseJson.message.replace(/\n+[-*\d][\S\s]*/g, ""));
      botMessage.classList.remove("bot-message-loading");
    }

    // If there are any product IDs...
    if (extractedIds.length > 0) {
      // Construct root products div
      const botProductsDiv = document.createElement("div");
      botProductsDiv.classList.add("bot-products");

      // For each product...
      for (const id of extractedIds) {
        // Retrieve product metadata from the Product Catalog
        const productResponse = await fetch("{{ $.baseUrl }}/product-meta/" + id, {
          method: "GET",
          headers: {
            "Content-Type": "application/json",
          },
        });
        const product = await productResponse.json();

        // Construct main product div
        const botProductDiv = document.createElement("a");
        botProductDiv.classList.add("bot-product");
        botProductDiv.href = "{{ $.baseUrl }}/product/" + id;

        // Construct product image
        const botProductImg = document.createElement("img");
        botProductImg.src = product["picture"];
        botProductImg.classList.add("bot-product-img");
        botProductImg.onerror = function() { this.style.display = 'none'; };
        botProductDiv.appendChild(botProductImg);

        // Construct product description div
        const botProductDescription = document.createElement("div");
        botProductDescription.classList.add("bot-product-description");
        let productDescription = product["description"];
        if (productDescription.length > 350) { // Shorten descriptions that are too long
          productDescription = productDescription.substring(0, 330) + '...';
        }
        botProductDescription.innerHTML = "<b>" + product["name"] + "</b><br>" + productDescription;
        botProductDiv.appendChild(botProductDescription);

        // Append main product div into the root products div
        botProductsDiv.appendChild(botProductDiv);
      }
      // Render products
      botMessages.appendChild(botProductsDiv)
    }

    botMessages.scrollTo(0, botMessages.scrollHeight);

    // Re-enable button and input field
    botbutton.disabled = false;
    botinput.disabled = false;
    botinput.focus();
  }

  main();
</script>

{{ end }}
